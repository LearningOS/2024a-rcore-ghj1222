实验报告

# 实现的功能

实现了 usercheck：给定一段区间，检查用户对它的访问是否合法。目前只实现了写入，因此只检查是否可写。

实现了 copyout：向用户页表的虚拟地址中复制数据，用于内核空间向用户空间传数据。

实现了 mmap和munmap：向用户 Memoryset 中加入用户自定义的一段映射区间。

# 问答题

1. 

页表项，高54位为物理页号，低10位是标志位，从低到高分别为：VRWXUGAD

V表示页表项是否有效。

RWX分别表示页面的权限是否可读可写可执行，如果都为0则说明这个页表项指向下一级页表。

U表示用户是否有权限访问这一页。

2. 

Load page fault 和 Store page fault 可能由缺页导致

stvec是异常处理程序的地址
sepc表示发生异常时的指令
scause表示异常种类（Load page fault 和 Store page fault 分别是13和15）
sscratch是一个临时的寄存器
sstatus存储了一些控制状态

lazy策略的好处是程序不一定使用其本身的所有代码段，可以降低内存访问和io的次数，也可以加快程序执行

处理10GB的连续内存，大概是2.5M个页，就需要2.5M个三级页表项，5K个二级页表项，10个一级页表项，加起来大概2.505M个页表项，一个页表项占用8字节，因此需要大约20.04MB的页表

实现lazy策略可以利用页表项为操作系统预留的标记，分配时使用一个位标记为lazy分配并把页表项的V设为0，当触发page fault时在异常处理程序中检测是否为lazy分配，如果是，就分配页面、修改页表，并返回让程序继续执行

如果因为swap策略导致页面失效，可以使用另一个位标记swap，处理策略和lazy大致相同

3.

单页表情况下在线程调度时切换页表，在异常时不需要切换页表

单页表时只需要把内核页面页表项的U设置0就可以了

单页表的优势在于陷入内核时不需要切换页表，一般程序运行时，陷入内核的次数肯定时比线程切换的次数多的（因为线程切换必须进入内核，而进入内核不一定去切换线程了），可以减少页表切换开销

双页表时在异常陷入内核时更换为内核页表，返回用户态时更换为用户页表。单页表的操作系统只在调度线程时更换对应线程的页表。


# 荣誉准则

    在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

        没有，没有，没有。

    此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

        [实验指导书](https://learningos.cn/rCore-Camp-Guide-2024A/chapter4/7exercise.html)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

